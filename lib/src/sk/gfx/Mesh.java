package sk.gfx;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL15.*;
import static org.lwjgl.opengl.GL30.*;
import static org.lwjgl.opengl.GL20.*;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;


public class Mesh {
	
	private int vao;
	
	private int[] vbos;
	
	private int ibo;
	
	private int vertexCount;
	private int indexCount;
	
	private int mode = GL_TRIANGLES;
	
	/**
	 * 
	 * Creates an empty mesh.
	 * {@link #generate(Vertex[] vertices, int... indices) generate()} should be called before use.
	 * 
	 */
	public Mesh() {
		
	}
	
	/**
	 * 
	 * Creates a mesh from the specified vertices and indices. If no indices are specified,
	 * then no indexing will be used.
	 * 
	 * @param vertices the vertices to be used.
	 * @param indices the indices to be used. If indices are not wished-for, don't supply any.
	 */
	public Mesh(Vertex[] vertices, int... indices) {
		generate(vertices, indices);
	}
	
	/**
	 * 
	 * Called to generate the mesh.
	 * Should not be called if data has already been supplied via constructor.
	 * 
	 * @param vertices the vertices to be used.
	 * @param indices the indices to be used. If indices are not wished-for, don't supply any.
	 */
	public void generate(Vertex[] vertices, int... indices) {
		vao = glGenVertexArrays();
		
		glBindVertexArray(vao);
		
		Vertex ref = vertices[0];
		
		vbos = new int[ref.getNumComponents()];
		
		for(int i = 0; i < vbos.length; i++) {
			vbos[i] = glGenBuffers();
			
			int len = ref.getLength(i);
			
			float[] data = new float[vertices.length * len];
			
			for(int j = 0; j < vertices.length; j++) {
				for(int k = 0; k < len; k++)
					data[j * len + k] = vertices[j].getData(i)[k];
			}
			
			FloatBuffer buffer = ByteBuffer.allocateDirect((vertices.length * len) << 2)
					.order(ByteOrder.nativeOrder()).asFloatBuffer();
			
			buffer.put(data);
			buffer.flip();
			
			glBindBuffer(GL_ARRAY_BUFFER, vbos[i]);
			
			glBufferData(GL_ARRAY_BUFFER, buffer, GL_STATIC_DRAW);
			
			glEnableVertexAttribArray(i);
			glVertexAttribPointer(i, len, GL_FLOAT, false, 0, 0);
		}
		
		if(indices.length > 0) {
			indexCount = indices.length;
			
			ibo = glGenBuffers();
			
			IntBuffer buffer = ByteBuffer.allocateDirect((indices.length) << 2)
					.order(ByteOrder.nativeOrder()).asIntBuffer();
			
			buffer.put(indices);
			buffer.flip();
			
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
			glBufferData(GL_ELEMENT_ARRAY_BUFFER, buffer, GL_STATIC_DRAW);
		}
		
		glBindVertexArray(0);
		
		vertexCount = vertices.length;
	}
	
	/**
	 * 
	 * Renders the mesh into the active buffer.
	 * 
	 */
	public void draw() {
		glBindVertexArray(vao);
		
		if(indexCount > 0) {
			glDrawElements(mode, indexCount, GL_UNSIGNED_INT, 0);
		} else {
			glDrawArrays(mode, 0, vertexCount);
		}
		
		glBindVertexArray(0);
	}
	
	/**
	 * 
	 * Deletes the VAO and VBOs generated by this mesh.
	 * 
	 */
	public void destroy() {
		glDeleteVertexArrays(vao);
		
		for(int i : vbos)
			glDeleteBuffers(i);
	}
	
	public int getMode() {
		return mode;
	}
	
	public Mesh setMode(int mode) {
		this.mode = mode;
		
		return this;
	}
	
	public static final Mesh QUAD;
	
	static {
		QUAD = new Mesh(new Vertex2D[] {
				new Vertex2D(-.5f, .5f, 0, 0),
				new Vertex2D(.5f, .5f, 1, 0),
				new Vertex2D(.5f, -.5f, 1, 1),
				new Vertex2D(-.5f, -.5f, 0, 1)
		}, 0, 1, 3, 3, 1, 2);
	}
	
	/**
	 * 
	 * Destroys all engine-created meshes.
	 * 
	 */
	public static final void destroyAll() {
		QUAD.destroy();
	}
}